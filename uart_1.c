
/*
*****************************************************************************
**
**      Project     : My project
**
**      Component   : MakeApp (LPC2138)
**
**      Modulename  : System
**
**      Filename    : template.c
**
**      Abstract    : This file is the template file for an application
**                    Rename the file from <template.c> to e.g. <usercode.c>
**                    The file contains an example of main function
**
**                    Modify the <usercode.c> to suit your application.
**                    The <usercode.c> file will not be overwritten by MakeApp.
**
**      Date        : 2006-02-08 10:26:02
**
**      License no. : 9532-355-016-8098     Furman's
**
**      Warning     : This file has been automatically generated.
**                    Do not edit this file if you intend to regenerate it.
**
**      This template file was created by IAR MakeApp version
**      4.10C (Philips LPC2138-48: 4.01B) for the Philips LPC2138 series of
**      microcontrollers.
**
**      (c)Copyright 2004-2005 MakeApp Consulting.
**
*****************************************************************************
*/
/*
**===========================================================================
**  1       GENERAL
**  1.1     Revisions
**
**  Please read the IAR MakeApp for Philips LPC2138-48 readme file
**
**
**===========================================================================
*/

/*
**===========================================================================
**  1.2     References
**
**  No   Identification          Name or Description
**  ==   ===================     ================================
**  1    November 22, 2004       Philips LPC2131/2132/2138
**                               User Manual, Preliminary Release
**
**===========================================================================
*/

/*
**===========================================================================
**  2.      INCLUDE FILES
**  2.1     Standard include files
**===========================================================================
*/
#include "type.h"
#include "timers.h"
#include "intrinsics.h"
#include "usercode.h"   /* Usercode macros (see <template.h>) */
#include <iolpc2138.h>
#include "macros.h"
#include "menu.hpp"
#include "uart_0.h"
#include "modbus.h"
/*
**===========================================================================
**  2.2     Application include files
**===========================================================================
*/


/*
**---------------------------------------------------
**  IAR MakeApp peripheral modules header files
**  Include the header files used by the application
**---------------------------------------------------
*/


/*
**===========================================================================
**  3.      DECLARATIONS
**  3.1     Internal constants
**===========================================================================
*/



/*
**===========================================================================
**  3.2     Internal macros
**===========================================================================
*/

#define RLS_ 3
#define RDA_ 2
#define CTI_ 6
#define THRE_ 1

/*
**===========================================================================
**  3.3     Internal type definitions
**===========================================================================
*/

/*
**===========================================================================
**  3.4     Global variables (declared as 'extern' in some header file)
**===========================================================================
*/

/*
**===========================================================================
**  3.5     Internal function prototypes (defined in Section 5)
**===========================================================================
*/

/*
**===========================================================================
**  3.6     Internal variables
**===========================================================================
*/
unsigned short CRCtx1,CRCrx1;

LIST *uart1_wr_ptr; //global pointer for outgoing thread
LIST *uart1_rd_ptr;  //global pointer for ingoing thread

union{
    char uart1_status;
    RXTX uart1_sts_bit;
};


extern PARAMETRS N;
/*
**===========================================================================
**  4.      GLOBAL FUNCTIONS (declared as 'extern' in some header file)
**===========================================================================
*/

/*
struct list{
    char *ptr;              //Operands pointer
    unsigned int count;     //count of bytes
    struct list *next;      //pointer for next element of list
};
*/


//RESPONSE_HEAD rx_temp_head;

LIST uart1_wr_manag[3];
LIST uart1_rd_manag[2];

char crc_buf1[2];
LIST uart1_wr_crc;  //для відправки контрольної суми

void wr_uart1(char *src, unsigned int src_count, char *dest, unsigned int dest_count)
{

    //T0MR3 = T0TC + 2500000;//розмір паузи

    uart1_wr_crc.ptr = &crc_buf1[0];             //ця частина для відправлення контрольної суми
    uart1_wr_crc.count = 2;                     //підставляється  в перериванні після досягнення ДНА
    uart1_wr_crc.next = 0;

    uart1_wr_manag[0].ptr = src;                //джерело
    uart1_wr_manag[0].count = src_count;        //кількість байтів
    uart1_wr_manag[0].next = 0;                 //більше нема

    uart1_rd_manag[0].ptr = dest;               //не зберігати байти
    uart1_rd_manag[0].count = dest_count;       //1байт-команда, 2байти-адреса
    uart1_rd_manag[0].next = 0;                 //продовження

    uart1_wr_ptr = &uart1_wr_manag[0];          //ініціалізація поінтера запису
    uart1_rd_ptr = &uart1_rd_manag[0];          //ініціалізація поінтера читання

    CRCtx1_init();
    CRCrx1_init();
    //N.UART1.simplex
    if(uart1_sts_bit.not_respond){  //якщо відповіді небуло то немає сенсу в додатковому таймауті
        uart1_status = 0x00;        //стан початок прийому і передачі start_tx = 1 start_rx = 1;
        uart1_sts_bit.pre_time = 1; //ознака початку паузи перерд передачою
        uart1_sts_bit.start_tx = 1; //ознака початку передачі
        U1MCR_bit.DTR = 1;          //стати в передачу
        timer_uart[1] = 2;// 2/3mS
    }
    else{
        uart1_status = 0x00;        //стан початок прийому і передачі start_tx = 1 start_rx = 1;
        uart1_sts_bit.pre_time = 1; //ознака початку паузи перерд передачою

        timer_uart[1] = N.UART1.timeout*3;//розмір паузи
    }

}

void MA_IntHandler_UART1( void )
/*
**---------------------------------------------------------------------------
**
**  Abstract:
**      Takes care of the UART 1 interrupt.
**
**  Parameters:
**      None
**
**  Returns:
**      None
**
**---------------------------------------------------------------------------
*/
{
    volatile char dummy;
    char un;

    //if(U1IIR_bit.IP)return;//if no pending interrupts

    switch(U1IIR_bit.IID){//interrupt identification
      case RLS_: //recive line status
            dummy = U1LSR;
        break;

      case CTI_: //caracter timeout indicator
            uart1_sts_bit.timeout = 1;  //ознака детекту таймауту прийому
      case RDA_: //recive data available
        if(uart1_sts_bit.timeout)un = 16;//виймати все
        else un = 13;//запобігти спустошенню фіфо для генераціі таймауту передачі
        do{
            if(U1LSR_bit.DR){                      //якщо у буфері прийому є дані то виймати їх
                if(uart1_rd_ptr->count){                 //якщо є куди виймати
                    if(uart1_rd_ptr->ptr){               //якщо треба зберегти а не просто спорожнити
                        char byte = U1RBR;
                        *uart1_rd_ptr->ptr++ = byte;    //якщо поінтер не нульовий то розміститиза ним отриманий байт
                        CRC_rx1(byte);
                    }
                    else dummy = U1RBR;                 //виймати непотрібний байт

                    if(--uart1_rd_ptr->count == 0){      //декремент кількості байт прийнятих за цим поінтером якщо дорівнює 0 то спробувати перейти далі за списком
                        if(uart1_rd_ptr->next) uart1_rd_ptr = uart1_rd_ptr->next;//перевірка чи є наступне місце для прийому і запис наступного елементу списку в активну позицію передачі
                        else uart1_sts_bit.end_rx = 1;    //ознака кінця прийому
                    }
                }
                else dummy = U1RBR;//U1FCR_bit.RFR = 1;//RECIEV FIFO RESET//dummy = U1RBR; //виймати непотрібний байт для спустошення фіфо
            }
            else{
                dummy = U1RBR;//U1FCR_bit.RFR = 1;//RECIEV FIFO RESET//dummy = U1RBR; //виймати непотрібний байт для спустошення фіфо
                break;
            }
        }while(--un);
        if(uart1_sts_bit.timeout == 1) slave();
        break;

      case THRE_:
        do{
            //if(uart1_sts_bit.end_tx)break;
            //Передача
            if(uart1_wr_ptr->count){                             //якщо передано ще не всі дані за цим поінтрером
                if(U1LSR_bit.THRE){                              //якщо FIFO не переповнене
                    uart1_wr_ptr->count--;                       //декремент кількості байт на передачу
                    char byte = *uart1_wr_ptr->ptr;
                        CRC_tx1(byte);
                        U1THR = byte;
                    if(uart1_wr_ptr->ptr)*uart1_wr_ptr->ptr++;   //і якщо є дані на передачу то інкремент поінтера
                }else break; //при переповненому фіфо повторити спробу при наступному перериванні
            }
            else{
                if(uart1_wr_ptr->next)                   //перевірка чи є наступний блок даних на передачу
                    uart1_wr_ptr = uart1_wr_ptr->next;   //запис наступного елементу списку в активну позицію передачі
                else{
                    if(!uart1_sts_bit.cs){
                        uart1_sts_bit.cs = 1;//CRC було відправлено
                        uart1_wr_ptr = &uart1_wr_crc;
                        crc_buf1[0] = CRCtx1>>8;
                        crc_buf1[1] = CRCtx1;
                        //U1THR = CRCtx>>8;
                        //U1THR = CRCtx;
                        //return;
                    }else{
                        U1IER_bit.THREIE = 0; //зупинка передачі
                        uart1_sts_bit.end_tx = 1;             //ознака кінця передачі
                        /*
                        T0MR1 = (20000000/N.UART1.bitrate + 100) + T0TC; //+100uS
                        T0IR_bit.MR1INT = 1;   //int flag reset
                        T0MCR_bit.MR1INT = 1;  //enable interrupt for match channal 1;
                        T0MR3 = T0TC + 300;        //+100uS
                        T0IR_bit.MR3INT = 1;        //int flag reset
                        T0MCR_bit.MR3INT = 1;       //enable interrupt for match channal;
                        */
                        timer_uart[1] = 60000/N.UART1.bitrate + 2;// +2/3 mS
                        break;
                    }
                }
            }
        }while(1);
        break;
    }

} /* MA_IntHandler_UART1 */




void uart1_bitrate(int bitrate)
{
    char u1ier_back = U1IER;

    bitrate = 14745600*4/16/bitrate;

    U1IER = 0; //disable all interrupt from that uart

    U1LCR_bit.DLAB = 1;
    U1DLL = bitrate & 0xff;
    U1DLM = bitrate >> 8 & 0xff;
    U1LCR_bit.DLAB = 0;

    U1IER = u1ier_back;//enable interrupt from that uart
}

void uart1_word_length(char temp)
{
    //обмежити 5,6,7,8
    temp = temp - 5;
    U1LCR_bit.WLS = temp;//довжина слова
}

void uart1_stop_bit(char temp)
{
    //обмежити 1,2 тобто 0,1
    temp -= 1;// 1 or 2(1.5for 5bit word length) stop bits
    U1LCR_bit.SBS = temp;
}

void uart1_parity_enable(char temp)
{
    //0 - disable 1 - enable
    U1LCR_bit.PE = temp;
}

void uart1_parity_select(char temp)
{
    // обмежити odd, even, 1, 0  = 0 1 2 3
    U1LCR_bit.PS = temp;
}

void uart1_setup(int bitrate,char word_length,char stop_bit,char parity_enable, char parity_select)
{
    U1IER = 0; //disable all interrupt from that uart

    bitrate = 14745600*4/16/bitrate;

    U1LCR_bit.DLAB = 1;
    U1DLL = bitrate & 0xff;
    U1DLM = bitrate >> 8 & 0xff;
    U1LCR_bit.DLAB = 0;

    //обмежити 5,6,7,8
    word_length = word_length - 5;
    U1LCR_bit.WLS = word_length;//довжина слова

    //обмежити 1,2 тобто 0,1
    stop_bit -= 1;// 1 or 2(1.5for 5bit word length) stop bits
    U1LCR_bit.SBS = stop_bit;

    //0 - disable 1 - enable
    U1LCR_bit.PE = parity_enable;

    // обмежити odd, even, 1, 0  = 0 1 2 3
    U1LCR_bit.PS = parity_select;

    U1FCR_bit.RFR = 1;//reset rx fifo
    U1FCR_bit.TFR = 1;//reset tx fifo
    U1FCR_bit.FCRFE = 1;//fifo enable
    U1FCR_bit.RTLS = 3;//trigger level 14 bytes

    U1IER_bit.RDAIE = 1;//enable RDA interrupt
    U1IER_bit.THREIE = 1;//enable THRE interrupt
}
/*
**===========================================================================
**  5.      INTERNAL FUNCTIONS (declared in Section 3.5)
**===========================================================================
*/


/*
**===========================================================================
** END OF FILE
**===========================================================================
*/


